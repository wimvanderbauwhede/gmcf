#!/usr/bin/perl

# gannet-as: the Gannet Assembler

use warnings; 
use strict;
use bytes;

use Data::Dumper;

use Getopt::Std;
@ARGV or die "Please provide the input file name (.gas)\n";

my %opts = ();
getopts( 'vbhFW:Y:', \%opts );

if ( $opts{'h'} ) {
	die "
Gannet Assembler - generates Gannet bytecode from text-based Gannet packet description 
$0 [opts] [file.gas]
-v: Verbose
-b: Show bytes
-F: Treat numbers as floating point (default is integer)
-W=32|64: Word size (defaults to 32)
-Y YAML-config-file
\n";
}
my $WORDSZ = $opts{'W'} ? $opts{'W'} * 1 : 32;
my $v      = $opts{'v'} ? 1              : 0;
my $b      = $opts{'b'} ? 1              : 0;
my $F      = $opts{'F'} ? 1              : 0;

my $yml_file = $opts{'Y'} || 'SBA.yml';

my $nbytes = ( $WORDSZ == 64 ) ? 8 : 4;
my $all1s = ( $WORDSZ == 64 ) ? 18446744073709551616 : 4294967296;

#  [(56,48,40,32,)24,16,8,0];
my @bytes =
  ( $WORDSZ == 64 ) ? ( 56, 48, 40, 32, 24, 16, 8, 0 ) : ( 24, 16, 8, 0 );

my $filename     = $ARGV[0];
my $tdc_filename = $filename;
$tdc_filename =~ s/\.\w+//;
$tdc_filename .= '.tdc';

open( IN,  "<$filename" );
open( OUT, ">$tdc_filename" );
use YAML::Syck;

my $path =
  ( exists $ENV{'GANNET_DIR'} ) ? $ENV{'GANNET_DIR'} : '.';
if (not -d "$path/Assembler/") {
	mkdir "$path/Assembler/";
}
system("garnet -Y $yml_file --yaml");
my $sc_href  = YAML::Syck::LoadFile("$path/Assembler/ServiceConfiguration.yml"); # generated by garnet.rb --yaml
my $sba_href = YAML::Syck::LoadFile("$path/SystemConfigurations/$yml_file");

my %ServiceConfiguration = %{$sc_href};
my %SBA                  = %{$sba_href};
my %SystemConfiguration  = %{ $SBA{'System'} };

my %Symbol_Kinds = %{ $ServiceConfiguration{'Symbol_Kinds'} };
my $symbol_kinds_str = join( '|', keys(%Symbol_Kinds) );

my %Symbol_Types = %{ $ServiceConfiguration{'Symbol_Types'} };
my $symbol_type_str = join( '|', keys(%Symbol_Types) );

my %Packet_Types = %{ $ServiceConfiguration{'Packet_Types'} };
my $packet_type_str = join( '|', keys(%Packet_Types) );

my %ServiceInstances  = %{ $SystemConfiguration{'ServiceInstances'} };
my %Aliases   = %{ $SystemConfiguration{'Aliases'} };
my %Services   = %{ $SystemConfiguration{'Services'} };# unused
my %ALU_Names = %{ $SystemConfiguration{'ALU_Names'} };

my %ServiceNames = ();
for my $service_id ( keys %ServiceInstances ) {
#die Dumper(%ServiceInstances);
	my %entries=%{$ServiceInstances{$service_id}};
	for my $name (keys %entries) {
		next if $name eq 'Addr';
		my $scid=$entries{$name}->[0];
		$ServiceNames{$name} = [$service_id, $scid];
	}
#my $name = $ServiceInstances{$service_id}[2];
#	$ServiceNames{$name} = $service_id;
}
$ServiceNames{'GW'} = [0,0]; # SBA.yml has 'GATEWAY', not 'GW'
#  ASSIGN: [LET, 0, 90]
my %AliasIDs = ();
for my $alias_id ( keys %Aliases ) {
	my $name = $Aliases{$alias_id}[2];
	$AliasIDs{$alias_id} = $name;
}

my %AliasNames = ();
for my $alias_id ( keys %Aliases ) {
	my $name = $Aliases{$alias_id}[0];
	$AliasIDs{$alias_id} = $name;
}

my $FS_SCId= $ServiceConfiguration{'FS_SCId'};

my $NPackets       = 0;
my @Packet_Header  = ();
my @Packet_Payload = ();
my %Vars= ();
my $var_counter=0;
my $reg_counter=0;

my $block_comment=0;

while (<IN>) {
	chomp;
    if ( /^\s*(=begin|\{\-)\s*$/ ) {
                    $block_comment=1;
                }
    if ( /^\s*(=end|\-\})\s*$/ ) {
                    $block_comment=0;
                }
    $block_comment && next;
# We treat == , -- , # and ; as comments
	/==|--|^\s*[\#\;]|^\s*$/ && next;
	s/^\s+//;
	s/\s+$//;
	s/\s*\#.*$//;
	s/\s+\(.*$//;
	!/:/ && /(\w+)\s*=\s*(.*)$/ && do {
		no strict 'refs';
		my $var=$1;
		my $val=$2;
#		print "val:$val\n";
		$val=~s/\$/\$::/g;
#		print "val:$val\n";
		${"::".$var}=eval($val);
#		print $var,'=',$$var,"\n";
	};

	/^NPackets:\s*(\d+)/ && do {
		$NPackets = $1;
		&write_npackets($NPackets);
		next;
	};
	/^($packet_type_str)/ && do {
		my @hw1_fields = num_hw1($_);
		&write_hw1(@hw1_fields);
		next;
	};
	/^([-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?)$/ && do {
		my $num = $1;
		&write_num($num);
		next;
	};
	/^(\w+\:.+)$/ && do {
		my @num_sym_fields = &num_sym($_);
		&write_sym(@num_sym_fields);
		next;
	};
}

close IN;
close OUT;

sub num_hw1 {
	my $hw1str        = shift;
	my @HW1           = split( ':', $hw1str );
	my $packet_type   = $Packet_Types{ $HW1[0] };
	my $redir         = $HW1[1];
	my $prio          = $HW1[2];
	my $packet_length = $HW1[3];
	my $dst           = uc( $HW1[4] );
	my $src           = uc( $HW1[5] );
	my $to =
	    exists( $ServiceNames{$dst} ) ? $ServiceNames{$dst}->[0]
	  : ( $dst =~ /d+/ ) ? $dst
	  :                    -1;
	my $return_to =
	  exists( $ServiceNames{$src} )
	  ? $ServiceNames{$src}->[0]
	  : ( ( $src =~ /d+/ ) ? $src : -1 );
	my @hw1_fields =
	  ( $packet_type, $redir, $prio, $packet_length, $to, $return_to );
	return @hw1_fields;
}

sub num_sym {
	my $symstr = shift;
	my @sym = split( ':', $symstr );
#print "num_sym: $symstr\n";
	my $kind = $Symbol_Kinds{ $sym[0] };     # assuming no rubbish :-) 
	if (not defined $Symbol_Kinds{ $sym[0] }) {
		$kind=$sym[0];
	}
	my $datatype = $Symbol_Types{ $sym[1] } || $sym[1];
	my $quoted  = $sym[3];    
	my $ext     = $sym[2];   
	my $task    = $sym[4];
	my $subtask = $sym[5];
	
	my $name = -1;
	if ($sym[0] eq 'L') {
		if (exists ($Vars{ $sym[6]} ) ) {
			$name = $Vars{ $sym[6]};
		} else {
			$var_counter++;
			$Vars{$sym[6]}=$var_counter;
			$name=$var_counter
		}			
	} else {
		my $name_scid=&lookup_name($sym[0], $sym[6] );
		$name=$name_scid->[0]+($name_scid->[1]<<$FS_SCId);
	}		
	my @sym_fields =
	  ( $kind, $datatype, $ext, $quoted, $task, $subtask, $name );
	return @sym_fields;
}

sub lookup_name {
	my $name = uc( $_[1] );
	if ($_[0] eq 'L') {
		if (exists ($Vars{ $name} ) ) {
			$name = $Vars{ $name};
		} else {
			$var_counter++;
			$Vars{$name}=$var_counter;
			$name=$var_counter
		}			
	} else {

	# first check if it's a service
	if ( exists( $ServiceNames{$name} ) ) {
		return $ServiceNames{$name};

		# then check if it's an alias
	} elsif ( exists( $Aliases{$name} ) ) {
		my $service=$Aliases{$name}[0];
		if ($_[0] ne 'R') {
			my $scid=$ServiceNames{$service}->[1];
			return [$Aliases{$name}[2],$scid];
		} else { # References need the Service name
			return $ServiceNames{$service};
		}			
		# and finally check if it's a ALU name
	}
	elsif ( exists( $ALU_Names{$name} ) ) {
		my $aluname = $ALU_Names{$name};
		my $service=$Aliases{$aluname}[0];
		if ($_[0] ne 'R') {
			my $scid=$ServiceNames{$service}->[1];
			return [$Aliases{$aluname}[2],$scid];
		} else { # References need the Service name
			return $ServiceNames{$service};
		}			

		# none of the above, check if it's a service number
	}
	elsif ( exists( $ServiceInstances{$name} ) ) {
		return [$name,0];
	}
	elsif ( exists( $AliasIDs{$name} ) ) {
		my $service=$Aliases{$name}[0];
		my $scid=$ServiceNames{$service}->[1];
		return [$name,$scid];
	}
	else {
		return -1;
	}
		}
}

sub write_npackets {
	my $npackets = shift;
	print "$npackets\n" if $v;
	my $npl   = ( $npackets % 256 );
	my $nph   = ( $npackets - $npl ) / 256;
	my @bytes = ();
	if ( $WORDSZ == 32 ) {
		@bytes = ( $nph, $npl, 0, 0 );
	}
	else {
		@bytes = ( $nph, $npl, 0, 0, 0, 0, 0, 0 );
	}
	&write_bytes(@bytes);
}

sub write_hw1 {
	my @hw1_fields = @_;
	print join( ':', @hw1_fields ), "\n" if $v;
	my @bytes = &hw1_to_bytes(@hw1_fields);

	&write_bytes(@bytes);
}

sub write_num {
	my $num = shift;
	print "$num\n" if $v;
	my @bytes = ();
	if ($F or "$num"=~/[\.eE]/) {
		@bytes = &flt_to_bytes($num);
	}
	else {
		@bytes = &int_to_bytes($num);
	}
	&write_bytes(@bytes);
}

sub write_str {
	my $str = shift;
	print "$str\n" if $v;

	# we assume pure ASCII 8-bit, so a character is a byte
	# however, I wonder about the \0 byte, I don't want it
	my @bytes = &str_to_bytes($str);
	&write_bytes(@bytes);
}

sub write_sym {
	my @sym_fields = @_;
	print join( ':', @sym_fields ), "\n" if $v;
	my @bytes = &gs_to_bytes(@sym_fields);
	&write_bytes(@bytes);
}

sub write_bytes {
	my @numbytes = @_;
	print join( ':', @numbytes ), "\n" if $b;
	print OUT pack( "CCCC", @numbytes );

	#for my $nb (@numbytes) {
	#    syswrite( OUT, chr($nb),1);
	#}
}

# -----------------------------------------------------------------------------
# Take a number, pack as IEEE double-precision floating point, unpack as 64-bit unsigned int
sub float_to_byteword {
	my $num = $_[0];
	my $flt = 0;
	if ( $WORDSZ == 64 ) {
		my @fltl = unpack( 'Q', pack( "D", ($num) ) );
		$flt = shift @fltl;
	}
	else {    # WORDSZ==32
		my @fltl = unpack( 'N', pack( "F", ($num) ) );
		$flt = shift @fltl;
	}    # WORDSZ
	return $flt;
}

# -----------------------------------------------------------------------------
#    # Take a number, pack as 2's complement signed int, unpack as 64-bit unsigned int
#    sub int_to_byteword { my $num=$_[0];
#        print "NUM: $num\n" if $v;
#        my $snum=0;
#        if ($num<0) {
#            $snum=0;
#        if ($WORDSZ==64) {
#            $snum=2**64+$num;
#        } else { # WORDSZ==32
#            $snum=2**32+$num;
#        } # WORDSZ
#        } else {
#            $snum=$num;
#        }
#        return $snum;
#    }

############################################################################

sub hw1_to_bytes {
	my @hw1       = @_;
	my $pt        = $hw1[0];    
	my $rd        = $hw1[1];    
	my $pr        = $hw1[2];    
	my $pto       = $hw1[4];    
	my $tl        = lo($pto);
	my $rto       = $hw1[5];    
	my $rtl       = lo($rto);
	my @byteword1 = ();
	if ( $WORDSZ == 64 ) {
		my $prrd = $pr * 8 + $rd;
		my $pl   = $hw1[3];            
		my $ll   = lo($pl);
		my $lh   = hi( $pl, $ll );
		my $th   = hi( $pto, $tl );
		my $rth  = hi( $rto, $rtl );
		return ( $pt, $prrd, $lh, $ll, $th, $tl, $rth, $rtl );
	}
	elsif ( $WORDSZ == 32 ) {
		my $pt_pr_rd = $pt * 32 + $pr * 4 + $rd;
		my $pl       = lo( $hw1[3] );              
		return ( $pt_pr_rd, $pl, $tl, $rtl );
	}

}

sub gs_to_bytes {
	my @gs = @_;
#	print 'B:',join(':',@gs),"\n";
	@gs = map { /\$/?do {s/\$/\$::/g;eval($_)}:$_} @gs;
	# kind|datatype|ext|quoted|task|subtask|name
#	print 'A:',join(':',@gs),"\n";
	my $st    = $gs[5];
	my $stl   = $st % 256;
	my $sth   = ( $st - $stl ) / 256;
	my $sname = $gs[6];
	if ( $gs[6] !~ /\d+/ ) {
		die "Name in " . join( ':', @gs ) . " not properly numerified\n";
	}
	my $sn   = $sname;
	my $nl   = $sn % 256;
	my $k    = $Symbol_Kinds{ $gs[0] } || $gs[0];
	my $dt   = $Symbol_Types{ $gs[1] } || $gs[1];
	my $q    = $gs[3];
	my $ext  = $gs[2];
	my $task = $gs[4];

	if ( $WORDSZ == 32 ) {
		my $kt = ( $dt < 4 ) ? 2 * $k + $dt : 2 * $k + ( $dt & 1 );
		my $kteqt = 16 * $kt + 8 * $ext + 4 * $q + $task;
		return ( $kteqt, $sth, $stl, $nl );
	}
	elsif ( $WORDSZ == 64 ) {
		my $kte = $k * 16 + $dt * 2 + $ext;
		my $qt  = ( $q << 6 ) + $task;
		my $nh  = ( $sn - $nl ) / 256;
		return ( $kte, $qt, $sth, $stl, $nh, $nl, 0, 0 );
	}
}

sub int_to_bytes {
	my $n        = $_[0];
	my @numbytes = ();
	if ( $n > 0 ) {
		@numbytes = map( { ( $n & ( 255 << $_ ) ) >> $_ } @bytes );
	}
	elsif ( $n == 0 ) {
		@numbytes = ( 0, 0, 0, 0 );
	}
	else {
		@numbytes = map { ( ( $all1s + $n ) & ( 255 << $_ ) ) >> $_ } @bytes;
	}
	return @numbytes;
}

sub flt_to_bytes {
	my $x    = $_[0];
	my $fltw = &float_to_byteword($x);
	return reverse( int_to_bytes($fltw) );    # WHY reverse?
}

sub str_to_bytes {
	my $str    = $_[0];
	my @bytes  = map { ord($_) } $str;
	my $nnulls = $nbytes - length(@bytes);

	if ( $nnulls > 0 ) {
		return ( @bytes, split( '', 0 x $nnulls ) );
	}
	else {
		return @bytes;
	}
}

sub lo {
	my $w16 = $_[0];
	$w16 % 256;
}

sub hi {
	( my $w16, my $lo ) = @_;
	( $w16 - $lo ) / 256;
}


=head1 NAME

Gannet Assembler

=head1 SYNOPSYS

The Gannet Assembler reads in a text file with the following structure:

	NPackets: an integer
	packet1: Packet Header, Packet Payload
	packet2
	...

=head2 Comments and blank lines

Any line starting with =,# or -- is a comment.
Blank lines are skipped
Block comments are in Haskell style: {- -} or Ruby style: =begin =end

=head2 Packet Header

The Packet Header consists of 3 words

=head3 Header Word 1

    # Header Word1: 8 | 5|3 | 16 | 16 | 16

    HW1 ::=    Type:Prio:Redir:Length:To:Return_to
    
    Type ::= subtask|code
    Prio ::= 0..31
    Redir ::= 0..7
    Length ::= uint16
    To ::= Address | Name
    Return_to ::= Address | Name
    
    Address ::= uint16
    Name ::= string
    
=head3 Header Word 2

    HW2 ::=  Redir==1 ? Sent_to : Length==0? ExtLength: 0
    
    Sent_to ::= Symbol
    ExtLength ::= uint32
    
=head3 Header Word 3

    HW3 ::= Return_as
    
    Return_as ::= Symbol
    
=head2 Packet Payload

As we're only dealing with code or subtask packets, the structure is always:

    Service Symbol (opcode)
    Symbol1 (operands)
    Symbol2
    ...
    
=head3 Symbols

# Symbol: 3|1|1|1|2 | 16 | 8

    Symbol ::= Kind:Datatype:Ext:Quoted:Task:Subtask:Name
    
=head3 Extended Symbol

If Ext==1, the Subtask field indicates the number of Extended Symbols

    Extended Symbol ::= uint32
            
=head1 EXAMPLE

    NPackets: 3
    ========
    subtask:0:0:4:alu:gateway
    0:8:0:0:0:0:0
    R:1:0:0:1:1:alu
    ------------
    S:4:0:0:1:1:/
    R:1:0:0:1:2:alu
    B:1:1:0:1:1:0
    -3.2
    
    ========
    code:0:0:4:alu:gateway
    0:8:0:0:0:0:0
    R:1:0:0:1:2:alu
    ------------
    S:4:0:0:1:2:*
    B:0:1:0:1:1:0
    2
    R:1:0:0:1:3:alu
    
    ========
    code:0:0:7:alu:gateway
    0:8:0:0:0:0:0
    R:1:0:0:1:3:alu
    ------------
    S:4:0:0:1:3:+
    B:1:1:0:1:1:0
    -4.2
    B:0:1:0:1:1:0
    -2
    B:0:1:0:1:1:0
    3
    
=head1 LIMITATIONS

We parse top-down, memoryless.
The line matching C</^\s*NPackets:(\d+)/> provides NPackets
Lines without C<:> are considered extended symbols, so either numbers or strings
Other lines are either Symbols or the first Header Word. The latter is distinguished by the keywords C<code> or C<Subtask>
The assembler does not do any checks on the "meaning" of the code, so it's up to the programmer to make sure that the packet and symbols structure makes sense.

=cut

